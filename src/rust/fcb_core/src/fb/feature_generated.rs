// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use crate::header_generated::*;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_CITY_OBJECT_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_CITY_OBJECT_TYPE: u8 = 32;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CITY_OBJECT_TYPE: [CityObjectType; 33] = [
    CityObjectType::Bridge,
    CityObjectType::BridgePart,
    CityObjectType::BridgeInstallation,
    CityObjectType::BridgeConstructiveElement,
    CityObjectType::BridgeRoom,
    CityObjectType::BridgeFurniture,
    CityObjectType::Building,
    CityObjectType::BuildingPart,
    CityObjectType::BuildingInstallation,
    CityObjectType::BuildingConstructiveElement,
    CityObjectType::BuildingFurniture,
    CityObjectType::BuildingStorey,
    CityObjectType::BuildingRoom,
    CityObjectType::BuildingUnit,
    CityObjectType::CityFurniture,
    CityObjectType::CityObjectGroup,
    CityObjectType::GenericCityObject,
    CityObjectType::LandUse,
    CityObjectType::OtherConstruction,
    CityObjectType::PlantCover,
    CityObjectType::SolitaryVegetationObject,
    CityObjectType::TINRelief,
    CityObjectType::Road,
    CityObjectType::Railway,
    CityObjectType::Waterway,
    CityObjectType::TransportSquare,
    CityObjectType::Tunnel,
    CityObjectType::TunnelPart,
    CityObjectType::TunnelInstallation,
    CityObjectType::TunnelConstructiveElement,
    CityObjectType::TunnelHollowSpace,
    CityObjectType::TunnelFurniture,
    CityObjectType::WaterBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CityObjectType(pub u8);
#[allow(non_upper_case_globals)]
impl CityObjectType {
    pub const Bridge: Self = Self(0);
    pub const BridgePart: Self = Self(1);
    pub const BridgeInstallation: Self = Self(2);
    pub const BridgeConstructiveElement: Self = Self(3);
    pub const BridgeRoom: Self = Self(4);
    pub const BridgeFurniture: Self = Self(5);
    pub const Building: Self = Self(6);
    pub const BuildingPart: Self = Self(7);
    pub const BuildingInstallation: Self = Self(8);
    pub const BuildingConstructiveElement: Self = Self(9);
    pub const BuildingFurniture: Self = Self(10);
    pub const BuildingStorey: Self = Self(11);
    pub const BuildingRoom: Self = Self(12);
    pub const BuildingUnit: Self = Self(13);
    pub const CityFurniture: Self = Self(14);
    pub const CityObjectGroup: Self = Self(15);
    pub const GenericCityObject: Self = Self(16);
    pub const LandUse: Self = Self(17);
    pub const OtherConstruction: Self = Self(18);
    pub const PlantCover: Self = Self(19);
    pub const SolitaryVegetationObject: Self = Self(20);
    pub const TINRelief: Self = Self(21);
    pub const Road: Self = Self(22);
    pub const Railway: Self = Self(23);
    pub const Waterway: Self = Self(24);
    pub const TransportSquare: Self = Self(25);
    pub const Tunnel: Self = Self(26);
    pub const TunnelPart: Self = Self(27);
    pub const TunnelInstallation: Self = Self(28);
    pub const TunnelConstructiveElement: Self = Self(29);
    pub const TunnelHollowSpace: Self = Self(30);
    pub const TunnelFurniture: Self = Self(31);
    pub const WaterBody: Self = Self(32);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 32;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::Bridge,
        Self::BridgePart,
        Self::BridgeInstallation,
        Self::BridgeConstructiveElement,
        Self::BridgeRoom,
        Self::BridgeFurniture,
        Self::Building,
        Self::BuildingPart,
        Self::BuildingInstallation,
        Self::BuildingConstructiveElement,
        Self::BuildingFurniture,
        Self::BuildingStorey,
        Self::BuildingRoom,
        Self::BuildingUnit,
        Self::CityFurniture,
        Self::CityObjectGroup,
        Self::GenericCityObject,
        Self::LandUse,
        Self::OtherConstruction,
        Self::PlantCover,
        Self::SolitaryVegetationObject,
        Self::TINRelief,
        Self::Road,
        Self::Railway,
        Self::Waterway,
        Self::TransportSquare,
        Self::Tunnel,
        Self::TunnelPart,
        Self::TunnelInstallation,
        Self::TunnelConstructiveElement,
        Self::TunnelHollowSpace,
        Self::TunnelFurniture,
        Self::WaterBody,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Bridge => Some("Bridge"),
            Self::BridgePart => Some("BridgePart"),
            Self::BridgeInstallation => Some("BridgeInstallation"),
            Self::BridgeConstructiveElement => Some("BridgeConstructiveElement"),
            Self::BridgeRoom => Some("BridgeRoom"),
            Self::BridgeFurniture => Some("BridgeFurniture"),
            Self::Building => Some("Building"),
            Self::BuildingPart => Some("BuildingPart"),
            Self::BuildingInstallation => Some("BuildingInstallation"),
            Self::BuildingConstructiveElement => Some("BuildingConstructiveElement"),
            Self::BuildingFurniture => Some("BuildingFurniture"),
            Self::BuildingStorey => Some("BuildingStorey"),
            Self::BuildingRoom => Some("BuildingRoom"),
            Self::BuildingUnit => Some("BuildingUnit"),
            Self::CityFurniture => Some("CityFurniture"),
            Self::CityObjectGroup => Some("CityObjectGroup"),
            Self::GenericCityObject => Some("GenericCityObject"),
            Self::LandUse => Some("LandUse"),
            Self::OtherConstruction => Some("OtherConstruction"),
            Self::PlantCover => Some("PlantCover"),
            Self::SolitaryVegetationObject => Some("SolitaryVegetationObject"),
            Self::TINRelief => Some("TINRelief"),
            Self::Road => Some("Road"),
            Self::Railway => Some("Railway"),
            Self::Waterway => Some("Waterway"),
            Self::TransportSquare => Some("TransportSquare"),
            Self::Tunnel => Some("Tunnel"),
            Self::TunnelPart => Some("TunnelPart"),
            Self::TunnelInstallation => Some("TunnelInstallation"),
            Self::TunnelConstructiveElement => Some("TunnelConstructiveElement"),
            Self::TunnelHollowSpace => Some("TunnelHollowSpace"),
            Self::TunnelFurniture => Some("TunnelFurniture"),
            Self::WaterBody => Some("WaterBody"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for CityObjectType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CityObjectType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for CityObjectType {
    type Output = CityObjectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CityObjectType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CityObjectType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CityObjectType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SEMANTIC_SURFACE_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SEMANTIC_SURFACE_TYPE: u8 = 17;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEMANTIC_SURFACE_TYPE: [SemanticSurfaceType; 18] = [
    SemanticSurfaceType::RoofSurface,
    SemanticSurfaceType::GroundSurface,
    SemanticSurfaceType::WallSurface,
    SemanticSurfaceType::ClosureSurface,
    SemanticSurfaceType::OuterCeilingSurface,
    SemanticSurfaceType::OuterFloorSurface,
    SemanticSurfaceType::Window,
    SemanticSurfaceType::Door,
    SemanticSurfaceType::InteriorWallSurface,
    SemanticSurfaceType::CeilingSurface,
    SemanticSurfaceType::FloorSurface,
    SemanticSurfaceType::WaterSurface,
    SemanticSurfaceType::WaterGroundSurface,
    SemanticSurfaceType::WaterClosureSurface,
    SemanticSurfaceType::TrafficArea,
    SemanticSurfaceType::AuxiliaryTrafficArea,
    SemanticSurfaceType::TransportationMarking,
    SemanticSurfaceType::TransportationHole,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SemanticSurfaceType(pub u8);
#[allow(non_upper_case_globals)]
impl SemanticSurfaceType {
    pub const RoofSurface: Self = Self(0);
    pub const GroundSurface: Self = Self(1);
    pub const WallSurface: Self = Self(2);
    pub const ClosureSurface: Self = Self(3);
    pub const OuterCeilingSurface: Self = Self(4);
    pub const OuterFloorSurface: Self = Self(5);
    pub const Window: Self = Self(6);
    pub const Door: Self = Self(7);
    pub const InteriorWallSurface: Self = Self(8);
    pub const CeilingSurface: Self = Self(9);
    pub const FloorSurface: Self = Self(10);
    pub const WaterSurface: Self = Self(11);
    pub const WaterGroundSurface: Self = Self(12);
    pub const WaterClosureSurface: Self = Self(13);
    pub const TrafficArea: Self = Self(14);
    pub const AuxiliaryTrafficArea: Self = Self(15);
    pub const TransportationMarking: Self = Self(16);
    pub const TransportationHole: Self = Self(17);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 17;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::RoofSurface,
        Self::GroundSurface,
        Self::WallSurface,
        Self::ClosureSurface,
        Self::OuterCeilingSurface,
        Self::OuterFloorSurface,
        Self::Window,
        Self::Door,
        Self::InteriorWallSurface,
        Self::CeilingSurface,
        Self::FloorSurface,
        Self::WaterSurface,
        Self::WaterGroundSurface,
        Self::WaterClosureSurface,
        Self::TrafficArea,
        Self::AuxiliaryTrafficArea,
        Self::TransportationMarking,
        Self::TransportationHole,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::RoofSurface => Some("RoofSurface"),
            Self::GroundSurface => Some("GroundSurface"),
            Self::WallSurface => Some("WallSurface"),
            Self::ClosureSurface => Some("ClosureSurface"),
            Self::OuterCeilingSurface => Some("OuterCeilingSurface"),
            Self::OuterFloorSurface => Some("OuterFloorSurface"),
            Self::Window => Some("Window"),
            Self::Door => Some("Door"),
            Self::InteriorWallSurface => Some("InteriorWallSurface"),
            Self::CeilingSurface => Some("CeilingSurface"),
            Self::FloorSurface => Some("FloorSurface"),
            Self::WaterSurface => Some("WaterSurface"),
            Self::WaterGroundSurface => Some("WaterGroundSurface"),
            Self::WaterClosureSurface => Some("WaterClosureSurface"),
            Self::TrafficArea => Some("TrafficArea"),
            Self::AuxiliaryTrafficArea => Some("AuxiliaryTrafficArea"),
            Self::TransportationMarking => Some("TransportationMarking"),
            Self::TransportationHole => Some("TransportationHole"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SemanticSurfaceType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SemanticSurfaceType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for SemanticSurfaceType {
    type Output = SemanticSurfaceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SemanticSurfaceType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SemanticSurfaceType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SemanticSurfaceType {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_GEOMETRY_TYPE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_GEOMETRY_TYPE: u8 = 6;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOMETRY_TYPE: [GeometryType; 7] = [
    GeometryType::MultiPoint,
    GeometryType::MultiLineString,
    GeometryType::MultiSurface,
    GeometryType::CompositeSurface,
    GeometryType::Solid,
    GeometryType::MultiSolid,
    GeometryType::CompositeSolid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeometryType(pub u8);
#[allow(non_upper_case_globals)]
impl GeometryType {
    pub const MultiPoint: Self = Self(0);
    pub const MultiLineString: Self = Self(1);
    pub const MultiSurface: Self = Self(2);
    pub const CompositeSurface: Self = Self(3);
    pub const Solid: Self = Self(4);
    pub const MultiSolid: Self = Self(5);
    pub const CompositeSolid: Self = Self(6);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 6;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::MultiPoint,
        Self::MultiLineString,
        Self::MultiSurface,
        Self::CompositeSurface,
        Self::Solid,
        Self::MultiSolid,
        Self::CompositeSolid,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::MultiPoint => Some("MultiPoint"),
            Self::MultiLineString => Some("MultiLineString"),
            Self::MultiSurface => Some("MultiSurface"),
            Self::CompositeSurface => Some("CompositeSurface"),
            Self::Solid => Some("Solid"),
            Self::MultiSolid => Some("MultiSolid"),
            Self::CompositeSolid => Some("CompositeSolid"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for GeometryType {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for GeometryType {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for GeometryType {
    type Output = GeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeometryType {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for GeometryType {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometryType {}
// struct Vertex, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq, Default)]
pub struct Vertex(pub [u8; 12]);
impl core::fmt::Debug for Vertex {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Vertex")
            .field("x", &self.x())
            .field("y", &self.y())
            .field("z", &self.z())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Vertex {}
impl<'a> flatbuffers::Follow<'a> for Vertex {
    type Inner = &'a Vertex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Vertex>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vertex {
    type Inner = &'a Vertex;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Vertex>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Vertex {
    type Output = Vertex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vertex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vertex {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Vertex {
    #[allow(clippy::too_many_arguments)]
    pub fn new(x: i32, y: i32, z: i32) -> Self {
        let mut s = Self([0; 12]);
        s.set_x(x);
        s.set_y(y);
        s.set_z(z);
        s
    }

    pub fn x(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_x(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn y(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_y(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn z(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_z(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum CityFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityFeature<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityFeature<'a> {
    type Inner = CityFeature<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CityFeature<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OBJECTS: flatbuffers::VOffsetT = 6;
    pub const VT_VERTICES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CityFeature { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CityFeatureArgs<'args>,
    ) -> flatbuffers::WIPOffset<CityFeature<'bldr>> {
        let mut builder = CityFeatureBuilder::new(_fbb);
        if let Some(x) = args.vertices {
            builder.add_vertices(x);
        }
        if let Some(x) = args.objects {
            builder.add_objects(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(CityFeature::VT_ID, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &CityFeature) -> bool {
        self.id() < o.id()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.id();
        key.cmp(val)
    }
    #[inline]
    pub fn objects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject>>,
            >>(CityFeature::VT_OBJECTS, None)
        }
    }
    #[inline]
    pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, Vertex>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vertex>>>(
                    CityFeature::VT_VERTICES,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for CityFeature<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CityObject>>,
            >>("objects", Self::VT_OBJECTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vertex>>>(
                "vertices",
                Self::VT_VERTICES,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct CityFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objects: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>,
        >,
    >,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vertex>>>,
}
impl Default for CityFeatureArgs<'_> {
    #[inline]
    fn default() -> Self {
        CityFeatureArgs {
            id: None, // required field
            objects: None,
            vertices: None,
        }
    }
}

pub struct CityFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityFeatureBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_ID, id);
    }
    #[inline]
    pub fn add_objects(
        &mut self,
        objects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<CityObject<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_OBJECTS, objects);
    }
    #[inline]
    pub fn add_vertices(
        &mut self,
        vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Vertex>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_VERTICES, vertices);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CityFeatureBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CityFeatureBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CityFeature<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, CityFeature::VT_ID, "id");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CityFeature<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CityFeature");
        ds.field("id", &self.id());
        ds.field("objects", &self.objects());
        ds.field("vertices", &self.vertices());
        ds.finish()
    }
}
pub enum CityObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityObject<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityObject<'a> {
    type Inner = CityObject<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> CityObject<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ID: flatbuffers::VOffsetT = 6;
    pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 8;
    pub const VT_GEOMETRY: flatbuffers::VOffsetT = 10;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
    pub const VT_COLUMNS: flatbuffers::VOffsetT = 14;
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 16;
    pub const VT_CHILDREN_ROLES: flatbuffers::VOffsetT = 18;
    pub const VT_PARENTS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CityObject { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CityObjectArgs<'args>,
    ) -> flatbuffers::WIPOffset<CityObject<'bldr>> {
        let mut builder = CityObjectBuilder::new(_fbb);
        if let Some(x) = args.parents {
            builder.add_parents(x);
        }
        if let Some(x) = args.children_roles {
            builder.add_children_roles(x);
        }
        if let Some(x) = args.children {
            builder.add_children(x);
        }
        if let Some(x) = args.columns {
            builder.add_columns(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        if let Some(x) = args.geometry {
            builder.add_geometry(x);
        }
        if let Some(x) = args.geographical_extent {
            builder.add_geographical_extent(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> CityObjectType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<CityObjectType>(CityObject::VT_TYPE_, Some(CityObjectType::Bridge))
                .unwrap()
        }
    }
    #[inline]
    pub fn id(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(CityObject::VT_ID, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn key_compare_less_than(&self, o: &CityObject) -> bool {
        self.id() < o.id()
    }

    #[inline]
    pub fn key_compare_with_value(&self, val: &str) -> ::core::cmp::Ordering {
        let key = self.id();
        key.cmp(val)
    }
    #[inline]
    pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, None)
        }
    }
    #[inline]
    pub fn geometry(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry>>,
            >>(CityObject::VT_GEOMETRY, None)
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    CityObject::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>,
            >>(CityObject::VT_COLUMNS, None)
        }
    }
    #[inline]
    pub fn children(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(CityObject::VT_CHILDREN, None)
        }
    }
    #[inline]
    pub fn children_roles(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(CityObject::VT_CHILDREN_ROLES, None)
        }
    }
    #[inline]
    pub fn parents(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(CityObject::VT_PARENTS, None)
        }
    }
}

impl flatbuffers::Verifiable for CityObject<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<CityObjectType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
            .visit_field::<GeographicalExtent>(
                "geographical_extent",
                Self::VT_GEOGRAPHICAL_EXTENT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Geometry>>,
            >>("geometry", Self::VT_GEOMETRY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>,
            >>("columns", Self::VT_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("children", Self::VT_CHILDREN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("children_roles", Self::VT_CHILDREN_ROLES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("parents", Self::VT_PARENTS, false)?
            .finish();
        Ok(())
    }
}
pub struct CityObjectArgs<'a> {
    pub type_: CityObjectType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub geometry: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>>,
    >,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>,
    >,
    pub children: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub children_roles: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub parents: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl Default for CityObjectArgs<'_> {
    #[inline]
    fn default() -> Self {
        CityObjectArgs {
            type_: CityObjectType::Bridge,
            id: None, // required field
            geographical_extent: None,
            geometry: None,
            attributes: None,
            columns: None,
            children: None,
            children_roles: None,
            parents: None,
        }
    }
}

pub struct CityObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityObjectBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: CityObjectType) {
        self.fbb_
            .push_slot::<CityObjectType>(CityObject::VT_TYPE_, type_, CityObjectType::Bridge);
    }
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ID, id);
    }
    #[inline]
    pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
        self.fbb_.push_slot_always::<&GeographicalExtent>(
            CityObject::VT_GEOGRAPHICAL_EXTENT,
            geographical_extent,
        );
    }
    #[inline]
    pub fn add_geometry(
        &mut self,
        geometry: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Geometry<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_GEOMETRY, geometry);
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ATTRIBUTES, attributes);
    }
    #[inline]
    pub fn add_columns(
        &mut self,
        columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Column<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_COLUMNS, columns);
    }
    #[inline]
    pub fn add_children(
        &mut self,
        children: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN, children);
    }
    #[inline]
    pub fn add_children_roles(
        &mut self,
        children_roles: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            CityObject::VT_CHILDREN_ROLES,
            children_roles,
        );
    }
    #[inline]
    pub fn add_parents(
        &mut self,
        parents: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_PARENTS, parents);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CityObjectBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CityObjectBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<CityObject<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, CityObject::VT_ID, "id");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for CityObject<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("CityObject");
        ds.field("type_", &self.type_());
        ds.field("id", &self.id());
        ds.field("geographical_extent", &self.geographical_extent());
        ds.field("geometry", &self.geometry());
        ds.field("attributes", &self.attributes());
        ds.field("columns", &self.columns());
        ds.field("children", &self.children());
        ds.field("children_roles", &self.children_roles());
        ds.field("parents", &self.parents());
        ds.finish()
    }
}
pub enum GeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Geometry<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Geometry<'a> {
    type Inner = Geometry<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Geometry<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_LOD: flatbuffers::VOffsetT = 6;
    pub const VT_SOLIDS: flatbuffers::VOffsetT = 8;
    pub const VT_SHELLS: flatbuffers::VOffsetT = 10;
    pub const VT_SURFACES: flatbuffers::VOffsetT = 12;
    pub const VT_STRINGS: flatbuffers::VOffsetT = 14;
    pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 16;
    pub const VT_SEMANTICS: flatbuffers::VOffsetT = 18;
    pub const VT_SEMANTICS_OBJECTS: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Geometry { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args GeometryArgs<'args>,
    ) -> flatbuffers::WIPOffset<Geometry<'bldr>> {
        let mut builder = GeometryBuilder::new(_fbb);
        if let Some(x) = args.semantics_objects {
            builder.add_semantics_objects(x);
        }
        if let Some(x) = args.semantics {
            builder.add_semantics(x);
        }
        if let Some(x) = args.boundaries {
            builder.add_boundaries(x);
        }
        if let Some(x) = args.strings {
            builder.add_strings(x);
        }
        if let Some(x) = args.surfaces {
            builder.add_surfaces(x);
        }
        if let Some(x) = args.shells {
            builder.add_shells(x);
        }
        if let Some(x) = args.solids {
            builder.add_solids(x);
        }
        if let Some(x) = args.lod {
            builder.add_lod(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> GeometryType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<GeometryType>(Geometry::VT_TYPE_, Some(GeometryType::MultiPoint))
                .unwrap()
        }
    }
    #[inline]
    pub fn lod(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Geometry::VT_LOD, None)
        }
    }
    #[inline]
    pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SOLIDS,
                    None,
                )
        }
    }
    #[inline]
    pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SHELLS,
                    None,
                )
        }
    }
    #[inline]
    pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SURFACES,
                    None,
                )
        }
    }
    #[inline]
    pub fn strings(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_STRINGS,
                    None,
                )
        }
    }
    #[inline]
    pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_BOUNDARIES,
                    None,
                )
        }
    }
    #[inline]
    pub fn semantics(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    Geometry::VT_SEMANTICS,
                    None,
                )
        }
    }
    #[inline]
    pub fn semantics_objects(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject>>,
            >>(Geometry::VT_SEMANTICS_OBJECTS, None)
        }
    }
}

impl flatbuffers::Verifiable for Geometry<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<GeometryType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lod", Self::VT_LOD, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "solids",
                Self::VT_SOLIDS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "shells",
                Self::VT_SHELLS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "surfaces",
                Self::VT_SURFACES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "strings",
                Self::VT_STRINGS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "boundaries",
                Self::VT_BOUNDARIES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "semantics",
                Self::VT_SEMANTICS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SemanticObject>>,
            >>("semantics_objects", Self::VT_SEMANTICS_OBJECTS, false)?
            .finish();
        Ok(())
    }
}
pub struct GeometryArgs<'a> {
    pub type_: GeometryType,
    pub lod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics_objects: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>,
        >,
    >,
}
impl Default for GeometryArgs<'_> {
    #[inline]
    fn default() -> Self {
        GeometryArgs {
            type_: GeometryType::MultiPoint,
            lod: None,
            solids: None,
            shells: None,
            surfaces: None,
            strings: None,
            boundaries: None,
            semantics: None,
            semantics_objects: None,
        }
    }
}

pub struct GeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeometryBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: GeometryType) {
        self.fbb_
            .push_slot::<GeometryType>(Geometry::VT_TYPE_, type_, GeometryType::MultiPoint);
    }
    #[inline]
    pub fn add_lod(&mut self, lod: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_LOD, lod);
    }
    #[inline]
    pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SOLIDS, solids);
    }
    #[inline]
    pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SHELLS, shells);
    }
    #[inline]
    pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SURFACES, surfaces);
    }
    #[inline]
    pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_STRINGS, strings);
    }
    #[inline]
    pub fn add_boundaries(
        &mut self,
        boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_BOUNDARIES, boundaries);
    }
    #[inline]
    pub fn add_semantics(
        &mut self,
        semantics: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS, semantics);
    }
    #[inline]
    pub fn add_semantics_objects(
        &mut self,
        semantics_objects: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SemanticObject<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Geometry::VT_SEMANTICS_OBJECTS,
            semantics_objects,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GeometryBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        GeometryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Geometry<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Geometry<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Geometry");
        ds.field("type_", &self.type_());
        ds.field("lod", &self.lod());
        ds.field("solids", &self.solids());
        ds.field("shells", &self.shells());
        ds.field("surfaces", &self.surfaces());
        ds.field("strings", &self.strings());
        ds.field("boundaries", &self.boundaries());
        ds.field("semantics", &self.semantics());
        ds.field("semantics_objects", &self.semantics_objects());
        ds.finish()
    }
}
pub enum SemanticObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SemanticObject<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SemanticObject<'a> {
    type Inner = SemanticObject<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SemanticObject<'a> {
    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
    pub const VT_CHILDREN: flatbuffers::VOffsetT = 8;
    pub const VT_PARENT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SemanticObject { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SemanticObjectArgs<'args>,
    ) -> flatbuffers::WIPOffset<SemanticObject<'bldr>> {
        let mut builder = SemanticObjectBuilder::new(_fbb);
        if let Some(x) = args.parent {
            builder.add_parent(x);
        }
        if let Some(x) = args.children {
            builder.add_children(x);
        }
        if let Some(x) = args.attributes {
            builder.add_attributes(x);
        }
        builder.add_type_(args.type_);
        builder.finish()
    }

    #[inline]
    pub fn type_(&self) -> SemanticSurfaceType {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<SemanticSurfaceType>(
                    SemanticObject::VT_TYPE_,
                    Some(SemanticSurfaceType::RoofSurface),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    SemanticObject::VT_ATTRIBUTES,
                    None,
                )
        }
    }
    #[inline]
    pub fn children(&self) -> Option<flatbuffers::Vector<'a, u32>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    SemanticObject::VT_CHILDREN,
                    None,
                )
        }
    }
    #[inline]
    pub fn parent(&self) -> Option<u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(SemanticObject::VT_PARENT, None) }
    }
}

impl flatbuffers::Verifiable for SemanticObject<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        v.visit_table(pos)?
            .visit_field::<SemanticSurfaceType>("type_", Self::VT_TYPE_, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "attributes",
                Self::VT_ATTRIBUTES,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "children",
                Self::VT_CHILDREN,
                false,
            )?
            .visit_field::<u32>("parent", Self::VT_PARENT, false)?
            .finish();
        Ok(())
    }
}
pub struct SemanticObjectArgs<'a> {
    pub type_: SemanticSurfaceType,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub parent: Option<u32>,
}
impl Default for SemanticObjectArgs<'_> {
    #[inline]
    fn default() -> Self {
        SemanticObjectArgs {
            type_: SemanticSurfaceType::RoofSurface,
            attributes: None,
            children: None,
            parent: None,
        }
    }
}

pub struct SemanticObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SemanticObjectBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_type_(&mut self, type_: SemanticSurfaceType) {
        self.fbb_.push_slot::<SemanticSurfaceType>(
            SemanticObject::VT_TYPE_,
            type_,
            SemanticSurfaceType::RoofSurface,
        );
    }
    #[inline]
    pub fn add_attributes(
        &mut self,
        attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SemanticObject::VT_ATTRIBUTES,
            attributes,
        );
    }
    #[inline]
    pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_CHILDREN, children);
    }
    #[inline]
    pub fn add_parent(&mut self, parent: u32) {
        self.fbb_
            .push_slot_always::<u32>(SemanticObject::VT_PARENT, parent);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SemanticObjectBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SemanticObjectBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SemanticObject<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SemanticObject<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SemanticObject");
        ds.field("type_", &self.type_());
        ds.field("attributes", &self.attributes());
        ds.field("children", &self.children());
        ds.field("parent", &self.parent());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CityFeature`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature(buf: &[u8]) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<CityFeature>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature(
    buf: &[u8],
) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<CityFeature>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CityFeature` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CityFeature`.
pub unsafe fn root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
    flatbuffers::root_unchecked::<CityFeature>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CityFeature`.
pub unsafe fn size_prefixed_root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
    flatbuffers::size_prefixed_root_unchecked::<CityFeature>(buf)
}
#[inline]
pub fn finish_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFeature<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFeature<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
