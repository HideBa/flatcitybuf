// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::header_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CITY_OBJECT_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CITY_OBJECT_TYPE: u8 = 32;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CITY_OBJECT_TYPE: [CityObjectType; 33] = [
  CityObjectType::Bridge,
  CityObjectType::BridgePart,
  CityObjectType::BridgeInstallation,
  CityObjectType::BridgeConstructiveElement,
  CityObjectType::BridgeRoom,
  CityObjectType::BridgeFurniture,
  CityObjectType::Building,
  CityObjectType::BuildingPart,
  CityObjectType::BuildingInstallation,
  CityObjectType::BuildingConstructiveElement,
  CityObjectType::BuildingFurniture,
  CityObjectType::BuildingStorey,
  CityObjectType::BuildingRoom,
  CityObjectType::BuildingUnit,
  CityObjectType::CityFurniture,
  CityObjectType::CityObjectGroup,
  CityObjectType::GenericCityObject,
  CityObjectType::LandUse,
  CityObjectType::OtherConstruction,
  CityObjectType::PlantCover,
  CityObjectType::SolitaryVegetationObject,
  CityObjectType::TINRelief,
  CityObjectType::Road,
  CityObjectType::Railway,
  CityObjectType::Waterway,
  CityObjectType::TransportSquare,
  CityObjectType::Tunnel,
  CityObjectType::TunnelPart,
  CityObjectType::TunnelInstallation,
  CityObjectType::TunnelConstructiveElement,
  CityObjectType::TunnelHollowSpace,
  CityObjectType::TunnelFurniture,
  CityObjectType::WaterBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CityObjectType(pub u8);
#[allow(non_upper_case_globals)]
impl CityObjectType {
  pub const Bridge: Self = Self(0);
  pub const BridgePart: Self = Self(1);
  pub const BridgeInstallation: Self = Self(2);
  pub const BridgeConstructiveElement: Self = Self(3);
  pub const BridgeRoom: Self = Self(4);
  pub const BridgeFurniture: Self = Self(5);
  pub const Building: Self = Self(6);
  pub const BuildingPart: Self = Self(7);
  pub const BuildingInstallation: Self = Self(8);
  pub const BuildingConstructiveElement: Self = Self(9);
  pub const BuildingFurniture: Self = Self(10);
  pub const BuildingStorey: Self = Self(11);
  pub const BuildingRoom: Self = Self(12);
  pub const BuildingUnit: Self = Self(13);
  pub const CityFurniture: Self = Self(14);
  pub const CityObjectGroup: Self = Self(15);
  pub const GenericCityObject: Self = Self(16);
  pub const LandUse: Self = Self(17);
  pub const OtherConstruction: Self = Self(18);
  pub const PlantCover: Self = Self(19);
  pub const SolitaryVegetationObject: Self = Self(20);
  pub const TINRelief: Self = Self(21);
  pub const Road: Self = Self(22);
  pub const Railway: Self = Self(23);
  pub const Waterway: Self = Self(24);
  pub const TransportSquare: Self = Self(25);
  pub const Tunnel: Self = Self(26);
  pub const TunnelPart: Self = Self(27);
  pub const TunnelInstallation: Self = Self(28);
  pub const TunnelConstructiveElement: Self = Self(29);
  pub const TunnelHollowSpace: Self = Self(30);
  pub const TunnelFurniture: Self = Self(31);
  pub const WaterBody: Self = Self(32);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 32;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Bridge,
    Self::BridgePart,
    Self::BridgeInstallation,
    Self::BridgeConstructiveElement,
    Self::BridgeRoom,
    Self::BridgeFurniture,
    Self::Building,
    Self::BuildingPart,
    Self::BuildingInstallation,
    Self::BuildingConstructiveElement,
    Self::BuildingFurniture,
    Self::BuildingStorey,
    Self::BuildingRoom,
    Self::BuildingUnit,
    Self::CityFurniture,
    Self::CityObjectGroup,
    Self::GenericCityObject,
    Self::LandUse,
    Self::OtherConstruction,
    Self::PlantCover,
    Self::SolitaryVegetationObject,
    Self::TINRelief,
    Self::Road,
    Self::Railway,
    Self::Waterway,
    Self::TransportSquare,
    Self::Tunnel,
    Self::TunnelPart,
    Self::TunnelInstallation,
    Self::TunnelConstructiveElement,
    Self::TunnelHollowSpace,
    Self::TunnelFurniture,
    Self::WaterBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Bridge => Some("Bridge"),
      Self::BridgePart => Some("BridgePart"),
      Self::BridgeInstallation => Some("BridgeInstallation"),
      Self::BridgeConstructiveElement => Some("BridgeConstructiveElement"),
      Self::BridgeRoom => Some("BridgeRoom"),
      Self::BridgeFurniture => Some("BridgeFurniture"),
      Self::Building => Some("Building"),
      Self::BuildingPart => Some("BuildingPart"),
      Self::BuildingInstallation => Some("BuildingInstallation"),
      Self::BuildingConstructiveElement => Some("BuildingConstructiveElement"),
      Self::BuildingFurniture => Some("BuildingFurniture"),
      Self::BuildingStorey => Some("BuildingStorey"),
      Self::BuildingRoom => Some("BuildingRoom"),
      Self::BuildingUnit => Some("BuildingUnit"),
      Self::CityFurniture => Some("CityFurniture"),
      Self::CityObjectGroup => Some("CityObjectGroup"),
      Self::GenericCityObject => Some("GenericCityObject"),
      Self::LandUse => Some("LandUse"),
      Self::OtherConstruction => Some("OtherConstruction"),
      Self::PlantCover => Some("PlantCover"),
      Self::SolitaryVegetationObject => Some("SolitaryVegetationObject"),
      Self::TINRelief => Some("TINRelief"),
      Self::Road => Some("Road"),
      Self::Railway => Some("Railway"),
      Self::Waterway => Some("Waterway"),
      Self::TransportSquare => Some("TransportSquare"),
      Self::Tunnel => Some("Tunnel"),
      Self::TunnelPart => Some("TunnelPart"),
      Self::TunnelInstallation => Some("TunnelInstallation"),
      Self::TunnelConstructiveElement => Some("TunnelConstructiveElement"),
      Self::TunnelHollowSpace => Some("TunnelHollowSpace"),
      Self::TunnelFurniture => Some("TunnelFurniture"),
      Self::WaterBody => Some("WaterBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CityObjectType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CityObjectType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CityObjectType {
    type Output = CityObjectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CityObjectType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CityObjectType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CityObjectType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SEMANTIC_SURFACE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SEMANTIC_SURFACE_TYPE: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEMANTIC_SURFACE_TYPE: [SemanticSurfaceType; 18] = [
  SemanticSurfaceType::RoofSurface,
  SemanticSurfaceType::GroundSurface,
  SemanticSurfaceType::WallSurface,
  SemanticSurfaceType::ClosureSurface,
  SemanticSurfaceType::OuterCeilingSurface,
  SemanticSurfaceType::OuterFloorSurface,
  SemanticSurfaceType::Window,
  SemanticSurfaceType::Door,
  SemanticSurfaceType::InteriorWallSurface,
  SemanticSurfaceType::CeilingSurface,
  SemanticSurfaceType::FloorSurface,
  SemanticSurfaceType::WaterSurface,
  SemanticSurfaceType::WaterGroundSurface,
  SemanticSurfaceType::WaterClosureSurface,
  SemanticSurfaceType::TrafficArea,
  SemanticSurfaceType::AuxiliaryTrafficArea,
  SemanticSurfaceType::TransportationMarking,
  SemanticSurfaceType::TransportationHole,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SemanticSurfaceType(pub u8);
#[allow(non_upper_case_globals)]
impl SemanticSurfaceType {
  pub const RoofSurface: Self = Self(0);
  pub const GroundSurface: Self = Self(1);
  pub const WallSurface: Self = Self(2);
  pub const ClosureSurface: Self = Self(3);
  pub const OuterCeilingSurface: Self = Self(4);
  pub const OuterFloorSurface: Self = Self(5);
  pub const Window: Self = Self(6);
  pub const Door: Self = Self(7);
  pub const InteriorWallSurface: Self = Self(8);
  pub const CeilingSurface: Self = Self(9);
  pub const FloorSurface: Self = Self(10);
  pub const WaterSurface: Self = Self(11);
  pub const WaterGroundSurface: Self = Self(12);
  pub const WaterClosureSurface: Self = Self(13);
  pub const TrafficArea: Self = Self(14);
  pub const AuxiliaryTrafficArea: Self = Self(15);
  pub const TransportationMarking: Self = Self(16);
  pub const TransportationHole: Self = Self(17);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RoofSurface,
    Self::GroundSurface,
    Self::WallSurface,
    Self::ClosureSurface,
    Self::OuterCeilingSurface,
    Self::OuterFloorSurface,
    Self::Window,
    Self::Door,
    Self::InteriorWallSurface,
    Self::CeilingSurface,
    Self::FloorSurface,
    Self::WaterSurface,
    Self::WaterGroundSurface,
    Self::WaterClosureSurface,
    Self::TrafficArea,
    Self::AuxiliaryTrafficArea,
    Self::TransportationMarking,
    Self::TransportationHole,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RoofSurface => Some("RoofSurface"),
      Self::GroundSurface => Some("GroundSurface"),
      Self::WallSurface => Some("WallSurface"),
      Self::ClosureSurface => Some("ClosureSurface"),
      Self::OuterCeilingSurface => Some("OuterCeilingSurface"),
      Self::OuterFloorSurface => Some("OuterFloorSurface"),
      Self::Window => Some("Window"),
      Self::Door => Some("Door"),
      Self::InteriorWallSurface => Some("InteriorWallSurface"),
      Self::CeilingSurface => Some("CeilingSurface"),
      Self::FloorSurface => Some("FloorSurface"),
      Self::WaterSurface => Some("WaterSurface"),
      Self::WaterGroundSurface => Some("WaterGroundSurface"),
      Self::WaterClosureSurface => Some("WaterClosureSurface"),
      Self::TrafficArea => Some("TrafficArea"),
      Self::AuxiliaryTrafficArea => Some("AuxiliaryTrafficArea"),
      Self::TransportationMarking => Some("TransportationMarking"),
      Self::TransportationHole => Some("TransportationHole"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SemanticSurfaceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SemanticSurfaceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SemanticSurfaceType {
    type Output = SemanticSurfaceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SemanticSurfaceType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SemanticSurfaceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SemanticSurfaceType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GEOMETRY_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GEOMETRY_TYPE: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOMETRY_TYPE: [GeometryType; 7] = [
  GeometryType::MultiPoint,
  GeometryType::MultiLineString,
  GeometryType::MultiSurface,
  GeometryType::CompositeSurface,
  GeometryType::Solid,
  GeometryType::MultiSolid,
  GeometryType::CompositeSolid,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeometryType(pub u8);
#[allow(non_upper_case_globals)]
impl GeometryType {
  pub const MultiPoint: Self = Self(0);
  pub const MultiLineString: Self = Self(1);
  pub const MultiSurface: Self = Self(2);
  pub const CompositeSurface: Self = Self(3);
  pub const Solid: Self = Self(4);
  pub const MultiSolid: Self = Self(5);
  pub const CompositeSolid: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MultiPoint,
    Self::MultiLineString,
    Self::MultiSurface,
    Self::CompositeSurface,
    Self::Solid,
    Self::MultiSolid,
    Self::CompositeSolid,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MultiPoint => Some("MultiPoint"),
      Self::MultiLineString => Some("MultiLineString"),
      Self::MultiSurface => Some("MultiSurface"),
      Self::CompositeSurface => Some("CompositeSurface"),
      Self::Solid => Some("Solid"),
      Self::MultiSolid => Some("MultiSolid"),
      Self::CompositeSolid => Some("CompositeSolid"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GeometryType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GeometryType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GeometryType {
    type Output = GeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeometryType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GeometryType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometryType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXTURE_FORMAT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXTURE_FORMAT: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXTURE_FORMAT: [TextureFormat; 2] = [
  TextureFormat::PNG,
  TextureFormat::JPG,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TextureFormat(pub u8);
#[allow(non_upper_case_globals)]
impl TextureFormat {
  pub const PNG: Self = Self(0);
  pub const JPG: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PNG,
    Self::JPG,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PNG => Some("PNG"),
      Self::JPG => Some("JPG"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TextureFormat {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TextureFormat {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TextureFormat {
    type Output = TextureFormat;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TextureFormat {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TextureFormat {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TextureFormat {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WRAP_MODE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WRAP_MODE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WRAP_MODE: [WrapMode; 5] = [
  WrapMode::None,
  WrapMode::Wrap,
  WrapMode::Mirror,
  WrapMode::Clamp,
  WrapMode::Border,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WrapMode(pub u8);
#[allow(non_upper_case_globals)]
impl WrapMode {
  pub const None: Self = Self(0);
  pub const Wrap: Self = Self(1);
  pub const Mirror: Self = Self(2);
  pub const Clamp: Self = Self(3);
  pub const Border: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::Wrap,
    Self::Mirror,
    Self::Clamp,
    Self::Border,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::Wrap => Some("Wrap"),
      Self::Mirror => Some("Mirror"),
      Self::Clamp => Some("Clamp"),
      Self::Border => Some("Border"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for WrapMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for WrapMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for WrapMode {
    type Output = WrapMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for WrapMode {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for WrapMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WrapMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXTURE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXTURE_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXTURE_TYPE: [TextureType; 3] = [
  TextureType::Unknown,
  TextureType::Specific,
  TextureType::Typical,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TextureType(pub u8);
#[allow(non_upper_case_globals)]
impl TextureType {
  pub const Unknown: Self = Self(0);
  pub const Specific: Self = Self(1);
  pub const Typical: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::Specific,
    Self::Typical,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::Specific => Some("Specific"),
      Self::Typical => Some("Typical"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TextureType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TextureType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TextureType {
    type Output = TextureType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TextureType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TextureType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TextureType {}
// struct Vertex, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vertex(pub [u8; 12]);
impl Default for Vertex { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Vertex {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vertex")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vertex {}
impl<'a> flatbuffers::Follow<'a> for Vertex {
  type Inner = &'a Vertex;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vertex>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vertex {
  type Inner = &'a Vertex;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vertex>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vertex {
    type Output = Vertex;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vertex as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vertex {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vertex {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: i32,
    y: i32,
    z: i32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> i32 {
    let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: i32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Vec2, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vec2(pub [u8; 8]);
impl Default for Vec2 { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for Vec2 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vec2")
      .field("u", &self.u())
      .field("v", &self.v())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vec2 {}
impl<'a> flatbuffers::Follow<'a> for Vec2 {
  type Inner = &'a Vec2;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vec2>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vec2 {
  type Inner = &'a Vec2;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vec2>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vec2 {
    type Output = Vec2;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vec2 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vec2 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vec2 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    u: f32,
    v: f32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_u(u);
    s.set_v(v);
    s
  }

  pub fn u(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_u(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn v(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_v(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum MaterialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Material<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Material<'a> {
  type Inner = Material<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Material<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_AMBIENT_INTENSITY: flatbuffers::VOffsetT = 6;
  pub const VT_DIFFUSE_COLOR: flatbuffers::VOffsetT = 8;
  pub const VT_EMISSIVE_COLOR: flatbuffers::VOffsetT = 10;
  pub const VT_SPECULAR_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_SHININESS: flatbuffers::VOffsetT = 14;
  pub const VT_TRANSPARENCY: flatbuffers::VOffsetT = 16;
  pub const VT_IS_SMOOTH: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Material { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MaterialArgs<'args>
  ) -> flatbuffers::WIPOffset<Material<'bldr>> {
    let mut builder = MaterialBuilder::new(_fbb);
    builder.add_transparency(args.transparency);
    builder.add_shininess(args.shininess);
    if let Some(x) = args.specular_color { builder.add_specular_color(x); }
    if let Some(x) = args.emissive_color { builder.add_emissive_color(x); }
    if let Some(x) = args.diffuse_color { builder.add_diffuse_color(x); }
    builder.add_ambient_intensity(args.ambient_intensity);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_is_smooth(args.is_smooth);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Material::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn ambient_intensity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Material::VT_AMBIENT_INTENSITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn diffuse_color(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Material::VT_DIFFUSE_COLOR, None)}
  }
  #[inline]
  pub fn emissive_color(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Material::VT_EMISSIVE_COLOR, None)}
  }
  #[inline]
  pub fn specular_color(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Material::VT_SPECULAR_COLOR, None)}
  }
  #[inline]
  pub fn shininess(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Material::VT_SHININESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn transparency(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Material::VT_TRANSPARENCY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn is_smooth(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Material::VT_IS_SMOOTH, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Material<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<f32>("ambient_intensity", Self::VT_AMBIENT_INTENSITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("diffuse_color", Self::VT_DIFFUSE_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("emissive_color", Self::VT_EMISSIVE_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("specular_color", Self::VT_SPECULAR_COLOR, false)?
     .visit_field::<f32>("shininess", Self::VT_SHININESS, false)?
     .visit_field::<f32>("transparency", Self::VT_TRANSPARENCY, false)?
     .visit_field::<bool>("is_smooth", Self::VT_IS_SMOOTH, false)?
     .finish();
    Ok(())
  }
}
pub struct MaterialArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ambient_intensity: f32,
    pub diffuse_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub emissive_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub specular_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub shininess: f32,
    pub transparency: f32,
    pub is_smooth: bool,
}
impl<'a> Default for MaterialArgs<'a> {
  #[inline]
  fn default() -> Self {
    MaterialArgs {
      name: None, // required field
      ambient_intensity: 0.0,
      diffuse_color: None,
      emissive_color: None,
      specular_color: None,
      shininess: 0.0,
      transparency: 0.0,
      is_smooth: false,
    }
  }
}

pub struct MaterialBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MaterialBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_NAME, name);
  }
  #[inline]
  pub fn add_ambient_intensity(&mut self, ambient_intensity: f32) {
    self.fbb_.push_slot::<f32>(Material::VT_AMBIENT_INTENSITY, ambient_intensity, 0.0);
  }
  #[inline]
  pub fn add_diffuse_color(&mut self, diffuse_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_DIFFUSE_COLOR, diffuse_color);
  }
  #[inline]
  pub fn add_emissive_color(&mut self, emissive_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_EMISSIVE_COLOR, emissive_color);
  }
  #[inline]
  pub fn add_specular_color(&mut self, specular_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Material::VT_SPECULAR_COLOR, specular_color);
  }
  #[inline]
  pub fn add_shininess(&mut self, shininess: f32) {
    self.fbb_.push_slot::<f32>(Material::VT_SHININESS, shininess, 0.0);
  }
  #[inline]
  pub fn add_transparency(&mut self, transparency: f32) {
    self.fbb_.push_slot::<f32>(Material::VT_TRANSPARENCY, transparency, 0.0);
  }
  #[inline]
  pub fn add_is_smooth(&mut self, is_smooth: bool) {
    self.fbb_.push_slot::<bool>(Material::VT_IS_SMOOTH, is_smooth, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MaterialBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MaterialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Material<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Material::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Material<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Material");
      ds.field("name", &self.name());
      ds.field("ambient_intensity", &self.ambient_intensity());
      ds.field("diffuse_color", &self.diffuse_color());
      ds.field("emissive_color", &self.emissive_color());
      ds.field("specular_color", &self.specular_color());
      ds.field("shininess", &self.shininess());
      ds.field("transparency", &self.transparency());
      ds.field("is_smooth", &self.is_smooth());
      ds.finish()
  }
}
pub enum TextureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Texture<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Texture<'a> {
  type Inner = Texture<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Texture<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 6;
  pub const VT_WRAP_MODE: flatbuffers::VOffsetT = 8;
  pub const VT_TEXTURE_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_BORDER_COLOR: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Texture { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextureArgs<'args>
  ) -> flatbuffers::WIPOffset<Texture<'bldr>> {
    let mut builder = TextureBuilder::new(_fbb);
    if let Some(x) = args.border_color { builder.add_border_color(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    builder.add_texture_type(args.texture_type);
    builder.add_wrap_mode(args.wrap_mode);
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> TextureFormat {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TextureFormat>(Texture::VT_TYPE_, Some(TextureFormat::PNG)).unwrap()}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Texture::VT_IMAGE, None)}
  }
  #[inline]
  pub fn wrap_mode(&self) -> WrapMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<WrapMode>(Texture::VT_WRAP_MODE, Some(WrapMode::None)).unwrap()}
  }
  #[inline]
  pub fn texture_type(&self) -> TextureType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TextureType>(Texture::VT_TEXTURE_TYPE, Some(TextureType::Unknown)).unwrap()}
  }
  #[inline]
  pub fn border_color(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Texture::VT_BORDER_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for Texture<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TextureFormat>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<WrapMode>("wrap_mode", Self::VT_WRAP_MODE, false)?
     .visit_field::<TextureType>("texture_type", Self::VT_TEXTURE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("border_color", Self::VT_BORDER_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct TextureArgs<'a> {
    pub type_: TextureFormat,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub wrap_mode: WrapMode,
    pub texture_type: TextureType,
    pub border_color: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for TextureArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextureArgs {
      type_: TextureFormat::PNG,
      image: None,
      wrap_mode: WrapMode::None,
      texture_type: TextureType::Unknown,
      border_color: None,
    }
  }
}

pub struct TextureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: TextureFormat) {
    self.fbb_.push_slot::<TextureFormat>(Texture::VT_TYPE_, type_, TextureFormat::PNG);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Texture::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_wrap_mode(&mut self, wrap_mode: WrapMode) {
    self.fbb_.push_slot::<WrapMode>(Texture::VT_WRAP_MODE, wrap_mode, WrapMode::None);
  }
  #[inline]
  pub fn add_texture_type(&mut self, texture_type: TextureType) {
    self.fbb_.push_slot::<TextureType>(Texture::VT_TEXTURE_TYPE, texture_type, TextureType::Unknown);
  }
  #[inline]
  pub fn add_border_color(&mut self, border_color: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Texture::VT_BORDER_COLOR, border_color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Texture<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Texture<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Texture");
      ds.field("type_", &self.type_());
      ds.field("image", &self.image());
      ds.field("wrap_mode", &self.wrap_mode());
      ds.field("texture_type", &self.texture_type());
      ds.field("border_color", &self.border_color());
      ds.finish()
  }
}
pub enum MaterialMappingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaterialMapping<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaterialMapping<'a> {
  type Inner = MaterialMapping<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MaterialMapping<'a> {
  pub const VT_THEME: flatbuffers::VOffsetT = 4;
  pub const VT_SOLIDS: flatbuffers::VOffsetT = 6;
  pub const VT_SHELLS: flatbuffers::VOffsetT = 8;
  pub const VT_VERTICES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MaterialMapping { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MaterialMappingArgs<'args>
  ) -> flatbuffers::WIPOffset<MaterialMapping<'bldr>> {
    let mut builder = MaterialMappingBuilder::new(_fbb);
    if let Some(x) = args.vertices { builder.add_vertices(x); }
    if let Some(x) = args.shells { builder.add_shells(x); }
    if let Some(x) = args.solids { builder.add_solids(x); }
    if let Some(x) = args.theme { builder.add_theme(x); }
    builder.finish()
  }


  #[inline]
  pub fn theme(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MaterialMapping::VT_THEME, None)}
  }
  #[inline]
  pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MaterialMapping::VT_SOLIDS, None)}
  }
  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MaterialMapping::VT_SHELLS, None)}
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(MaterialMapping::VT_VERTICES, None)}
  }
}

impl flatbuffers::Verifiable for MaterialMapping<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("theme", Self::VT_THEME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("solids", Self::VT_SOLIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("shells", Self::VT_SHELLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("vertices", Self::VT_VERTICES, false)?
     .finish();
    Ok(())
  }
}
pub struct MaterialMappingArgs<'a> {
    pub theme: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for MaterialMappingArgs<'a> {
  #[inline]
  fn default() -> Self {
    MaterialMappingArgs {
      theme: None,
      solids: None,
      shells: None,
      vertices: None,
    }
  }
}

pub struct MaterialMappingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MaterialMappingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_theme(&mut self, theme: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_THEME, theme);
  }
  #[inline]
  pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_SOLIDS, solids);
  }
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_SHELLS, shells);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MaterialMapping::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MaterialMappingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MaterialMappingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MaterialMapping<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MaterialMapping<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MaterialMapping");
      ds.field("theme", &self.theme());
      ds.field("solids", &self.solids());
      ds.field("shells", &self.shells());
      ds.field("vertices", &self.vertices());
      ds.finish()
  }
}
pub enum TextureMappingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TextureMapping<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TextureMapping<'a> {
  type Inner = TextureMapping<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TextureMapping<'a> {
  pub const VT_THEME: flatbuffers::VOffsetT = 4;
  pub const VT_SOLIDS: flatbuffers::VOffsetT = 6;
  pub const VT_SHELLS: flatbuffers::VOffsetT = 8;
  pub const VT_SURFACES: flatbuffers::VOffsetT = 10;
  pub const VT_STRINGS: flatbuffers::VOffsetT = 12;
  pub const VT_VERTICES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TextureMapping { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextureMappingArgs<'args>
  ) -> flatbuffers::WIPOffset<TextureMapping<'bldr>> {
    let mut builder = TextureMappingBuilder::new(_fbb);
    if let Some(x) = args.vertices { builder.add_vertices(x); }
    if let Some(x) = args.strings { builder.add_strings(x); }
    if let Some(x) = args.surfaces { builder.add_surfaces(x); }
    if let Some(x) = args.shells { builder.add_shells(x); }
    if let Some(x) = args.solids { builder.add_solids(x); }
    if let Some(x) = args.theme { builder.add_theme(x); }
    builder.finish()
  }


  #[inline]
  pub fn theme(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TextureMapping::VT_THEME, None)}
  }
  #[inline]
  pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TextureMapping::VT_SOLIDS, None)}
  }
  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TextureMapping::VT_SHELLS, None)}
  }
  #[inline]
  pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TextureMapping::VT_SURFACES, None)}
  }
  #[inline]
  pub fn strings(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TextureMapping::VT_STRINGS, None)}
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(TextureMapping::VT_VERTICES, None)}
  }
}

impl flatbuffers::Verifiable for TextureMapping<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("theme", Self::VT_THEME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("solids", Self::VT_SOLIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("shells", Self::VT_SHELLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("surfaces", Self::VT_SURFACES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("strings", Self::VT_STRINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("vertices", Self::VT_VERTICES, false)?
     .finish();
    Ok(())
  }
}
pub struct TextureMappingArgs<'a> {
    pub theme: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for TextureMappingArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextureMappingArgs {
      theme: None,
      solids: None,
      shells: None,
      surfaces: None,
      strings: None,
      vertices: None,
    }
  }
}

pub struct TextureMappingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextureMappingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_theme(&mut self, theme: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_THEME, theme);
  }
  #[inline]
  pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_SOLIDS, solids);
  }
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_SHELLS, shells);
  }
  #[inline]
  pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_SURFACES, surfaces);
  }
  #[inline]
  pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_STRINGS, strings);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextureMapping::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextureMappingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextureMappingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TextureMapping<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TextureMapping<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TextureMapping");
      ds.field("theme", &self.theme());
      ds.field("solids", &self.solids());
      ds.field("shells", &self.shells());
      ds.field("surfaces", &self.surfaces());
      ds.field("strings", &self.strings());
      ds.field("vertices", &self.vertices());
      ds.finish()
  }
}
pub enum AppearanceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Appearance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Appearance<'a> {
  type Inner = Appearance<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Appearance<'a> {
  pub const VT_MATERIALS: flatbuffers::VOffsetT = 4;
  pub const VT_TEXTURES: flatbuffers::VOffsetT = 6;
  pub const VT_VERTICES_TEXTURE: flatbuffers::VOffsetT = 8;
  pub const VT_DEFAULT_THEME_TEXTURE: flatbuffers::VOffsetT = 10;
  pub const VT_DEFAULT_THEME_MATERIAL: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Appearance { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppearanceArgs<'args>
  ) -> flatbuffers::WIPOffset<Appearance<'bldr>> {
    let mut builder = AppearanceBuilder::new(_fbb);
    if let Some(x) = args.default_theme_material { builder.add_default_theme_material(x); }
    if let Some(x) = args.default_theme_texture { builder.add_default_theme_texture(x); }
    if let Some(x) = args.vertices_texture { builder.add_vertices_texture(x); }
    if let Some(x) = args.textures { builder.add_textures(x); }
    if let Some(x) = args.materials { builder.add_materials(x); }
    builder.finish()
  }


  #[inline]
  pub fn materials(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material>>>>(Appearance::VT_MATERIALS, None)}
  }
  #[inline]
  pub fn textures(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture>>>>(Appearance::VT_TEXTURES, None)}
  }
  #[inline]
  pub fn vertices_texture(&self) -> Option<flatbuffers::Vector<'a, Vec2>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vec2>>>(Appearance::VT_VERTICES_TEXTURE, None)}
  }
  #[inline]
  pub fn default_theme_texture(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Appearance::VT_DEFAULT_THEME_TEXTURE, None)}
  }
  #[inline]
  pub fn default_theme_material(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Appearance::VT_DEFAULT_THEME_MATERIAL, None)}
  }
}

impl flatbuffers::Verifiable for Appearance<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Material>>>>("materials", Self::VT_MATERIALS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Texture>>>>("textures", Self::VT_TEXTURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vec2>>>("vertices_texture", Self::VT_VERTICES_TEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("default_theme_texture", Self::VT_DEFAULT_THEME_TEXTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("default_theme_material", Self::VT_DEFAULT_THEME_MATERIAL, false)?
     .finish();
    Ok(())
  }
}
pub struct AppearanceArgs<'a> {
    pub materials: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Material<'a>>>>>,
    pub textures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Texture<'a>>>>>,
    pub vertices_texture: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vec2>>>,
    pub default_theme_texture: Option<flatbuffers::WIPOffset<&'a str>>,
    pub default_theme_material: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AppearanceArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppearanceArgs {
      materials: None,
      textures: None,
      vertices_texture: None,
      default_theme_texture: None,
      default_theme_material: None,
    }
  }
}

pub struct AppearanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppearanceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_materials(&mut self, materials: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Material<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_MATERIALS, materials);
  }
  #[inline]
  pub fn add_textures(&mut self, textures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Texture<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_TEXTURES, textures);
  }
  #[inline]
  pub fn add_vertices_texture(&mut self, vertices_texture: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vec2>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_VERTICES_TEXTURE, vertices_texture);
  }
  #[inline]
  pub fn add_default_theme_texture(&mut self, default_theme_texture: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_DEFAULT_THEME_TEXTURE, default_theme_texture);
  }
  #[inline]
  pub fn add_default_theme_material(&mut self, default_theme_material: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Appearance::VT_DEFAULT_THEME_MATERIAL, default_theme_material);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppearanceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppearanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Appearance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Appearance<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Appearance");
      ds.field("materials", &self.materials());
      ds.field("textures", &self.textures());
      ds.field("vertices_texture", &self.vertices_texture());
      ds.field("default_theme_texture", &self.default_theme_texture());
      ds.field("default_theme_material", &self.default_theme_material());
      ds.finish()
  }
}
pub enum CityFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityFeature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityFeature<'a> {
  type Inner = CityFeature<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CityFeature<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECTS: flatbuffers::VOffsetT = 6;
  pub const VT_VERTICES: flatbuffers::VOffsetT = 8;
  pub const VT_APPEARANCE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CityFeature { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CityFeatureArgs<'args>
  ) -> flatbuffers::WIPOffset<CityFeature<'bldr>> {
    let mut builder = CityFeatureBuilder::new(_fbb);
    if let Some(x) = args.appearance { builder.add_appearance(x); }
    if let Some(x) = args.vertices { builder.add_vertices(x); }
    if let Some(x) = args.objects { builder.add_objects(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CityFeature::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &CityFeature) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn objects(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject>>>>(CityFeature::VT_OBJECTS, None)}
  }
  #[inline]
  pub fn vertices(&self) -> Option<flatbuffers::Vector<'a, Vertex>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vertex>>>(CityFeature::VT_VERTICES, None)}
  }
  #[inline]
  pub fn appearance(&self) -> Option<Appearance<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Appearance>>(CityFeature::VT_APPEARANCE, None)}
  }
}

impl flatbuffers::Verifiable for CityFeature<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CityObject>>>>("objects", Self::VT_OBJECTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vertex>>>("vertices", Self::VT_VERTICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Appearance>>("appearance", Self::VT_APPEARANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CityFeatureArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CityObject<'a>>>>>,
    pub vertices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vertex>>>,
    pub appearance: Option<flatbuffers::WIPOffset<Appearance<'a>>>,
}
impl<'a> Default for CityFeatureArgs<'a> {
  #[inline]
  fn default() -> Self {
    CityFeatureArgs {
      id: None, // required field
      objects: None,
      vertices: None,
      appearance: None,
    }
  }
}

pub struct CityFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityFeatureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_ID, id);
  }
  #[inline]
  pub fn add_objects(&mut self, objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CityObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_OBJECTS, objects);
  }
  #[inline]
  pub fn add_vertices(&mut self, vertices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vertex>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityFeature::VT_VERTICES, vertices);
  }
  #[inline]
  pub fn add_appearance(&mut self, appearance: flatbuffers::WIPOffset<Appearance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Appearance>>(CityFeature::VT_APPEARANCE, appearance);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CityFeatureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CityFeatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CityFeature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CityFeature::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CityFeature<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CityFeature");
      ds.field("id", &self.id());
      ds.field("objects", &self.objects());
      ds.field("vertices", &self.vertices());
      ds.field("appearance", &self.appearance());
      ds.finish()
  }
}
pub enum CityObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CityObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CityObject<'a> {
  type Inner = CityObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CityObject<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_GEOGRAPHICAL_EXTENT: flatbuffers::VOffsetT = 8;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 10;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 12;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 14;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 16;
  pub const VT_CHILDREN_ROLES: flatbuffers::VOffsetT = 18;
  pub const VT_PARENTS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CityObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CityObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<CityObject<'bldr>> {
    let mut builder = CityObjectBuilder::new(_fbb);
    if let Some(x) = args.parents { builder.add_parents(x); }
    if let Some(x) = args.children_roles { builder.add_children_roles(x); }
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    if let Some(x) = args.geographical_extent { builder.add_geographical_extent(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> CityObjectType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CityObjectType>(CityObject::VT_TYPE_, Some(CityObjectType::Bridge)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CityObject::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &CityObject) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn geographical_extent(&self) -> Option<&'a GeographicalExtent> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, None)}
  }
  #[inline]
  pub fn geometry(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry>>>>(CityObject::VT_GEOMETRY, None)}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CityObject::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column>>>>(CityObject::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_CHILDREN, None)}
  }
  #[inline]
  pub fn children_roles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_CHILDREN_ROLES, None)}
  }
  #[inline]
  pub fn parents(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(CityObject::VT_PARENTS, None)}
  }
}

impl flatbuffers::Verifiable for CityObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<CityObjectType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<GeographicalExtent>("geographical_extent", Self::VT_GEOGRAPHICAL_EXTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Geometry>>>>("geometry", Self::VT_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Column>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("children_roles", Self::VT_CHILDREN_ROLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("parents", Self::VT_PARENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct CityObjectArgs<'a> {
    pub type_: CityObjectType,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub geographical_extent: Option<&'a GeographicalExtent>,
    pub geometry: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Geometry<'a>>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Column<'a>>>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub children_roles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub parents: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for CityObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    CityObjectArgs {
      type_: CityObjectType::Bridge,
      id: None, // required field
      geographical_extent: None,
      geometry: None,
      attributes: None,
      columns: None,
      children: None,
      children_roles: None,
      parents: None,
    }
  }
}

pub struct CityObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CityObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: CityObjectType) {
    self.fbb_.push_slot::<CityObjectType>(CityObject::VT_TYPE_, type_, CityObjectType::Bridge);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ID, id);
  }
  #[inline]
  pub fn add_geographical_extent(&mut self, geographical_extent: &GeographicalExtent) {
    self.fbb_.push_slot_always::<&GeographicalExtent>(CityObject::VT_GEOGRAPHICAL_EXTENT, geographical_extent);
  }
  #[inline]
  pub fn add_geometry(&mut self, geometry: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Geometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Column<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_children_roles(&mut self, children_roles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_CHILDREN_ROLES, children_roles);
  }
  #[inline]
  pub fn add_parents(&mut self, parents: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CityObject::VT_PARENTS, parents);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CityObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CityObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CityObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CityObject::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CityObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CityObject");
      ds.field("type_", &self.type_());
      ds.field("id", &self.id());
      ds.field("geographical_extent", &self.geographical_extent());
      ds.field("geometry", &self.geometry());
      ds.field("attributes", &self.attributes());
      ds.field("columns", &self.columns());
      ds.field("children", &self.children());
      ds.field("children_roles", &self.children_roles());
      ds.field("parents", &self.parents());
      ds.finish()
  }
}
pub enum GeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Geometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Geometry<'a> {
  type Inner = Geometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Geometry<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_LOD: flatbuffers::VOffsetT = 6;
  pub const VT_SOLIDS: flatbuffers::VOffsetT = 8;
  pub const VT_SHELLS: flatbuffers::VOffsetT = 10;
  pub const VT_SURFACES: flatbuffers::VOffsetT = 12;
  pub const VT_STRINGS: flatbuffers::VOffsetT = 14;
  pub const VT_BOUNDARIES: flatbuffers::VOffsetT = 16;
  pub const VT_SEMANTICS: flatbuffers::VOffsetT = 18;
  pub const VT_SEMANTICS_OBJECTS: flatbuffers::VOffsetT = 20;
  pub const VT_MATERIAL: flatbuffers::VOffsetT = 22;
  pub const VT_TEXTURE: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Geometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<Geometry<'bldr>> {
    let mut builder = GeometryBuilder::new(_fbb);
    if let Some(x) = args.texture { builder.add_texture(x); }
    if let Some(x) = args.material { builder.add_material(x); }
    if let Some(x) = args.semantics_objects { builder.add_semantics_objects(x); }
    if let Some(x) = args.semantics { builder.add_semantics(x); }
    if let Some(x) = args.boundaries { builder.add_boundaries(x); }
    if let Some(x) = args.strings { builder.add_strings(x); }
    if let Some(x) = args.surfaces { builder.add_surfaces(x); }
    if let Some(x) = args.shells { builder.add_shells(x); }
    if let Some(x) = args.solids { builder.add_solids(x); }
    if let Some(x) = args.lod { builder.add_lod(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> GeometryType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometryType>(Geometry::VT_TYPE_, Some(GeometryType::MultiPoint)).unwrap()}
  }
  #[inline]
  pub fn lod(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Geometry::VT_LOD, None)}
  }
  #[inline]
  pub fn solids(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SOLIDS, None)}
  }
  #[inline]
  pub fn shells(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SHELLS, None)}
  }
  #[inline]
  pub fn surfaces(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SURFACES, None)}
  }
  #[inline]
  pub fn strings(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_STRINGS, None)}
  }
  #[inline]
  pub fn boundaries(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_BOUNDARIES, None)}
  }
  #[inline]
  pub fn semantics(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(Geometry::VT_SEMANTICS, None)}
  }
  #[inline]
  pub fn semantics_objects(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject>>>>(Geometry::VT_SEMANTICS_OBJECTS, None)}
  }
  #[inline]
  pub fn material(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapping<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapping>>>>(Geometry::VT_MATERIAL, None)}
  }
  #[inline]
  pub fn texture(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextureMapping<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextureMapping>>>>(Geometry::VT_TEXTURE, None)}
  }
}

impl flatbuffers::Verifiable for Geometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GeometryType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lod", Self::VT_LOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("solids", Self::VT_SOLIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("shells", Self::VT_SHELLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("surfaces", Self::VT_SURFACES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("strings", Self::VT_STRINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("boundaries", Self::VT_BOUNDARIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("semantics", Self::VT_SEMANTICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SemanticObject>>>>("semantics_objects", Self::VT_SEMANTICS_OBJECTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MaterialMapping>>>>("material", Self::VT_MATERIAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TextureMapping>>>>("texture", Self::VT_TEXTURE, false)?
     .finish();
    Ok(())
  }
}
pub struct GeometryArgs<'a> {
    pub type_: GeometryType,
    pub lod: Option<flatbuffers::WIPOffset<&'a str>>,
    pub solids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub shells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub surfaces: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub strings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub boundaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub semantics_objects: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SemanticObject<'a>>>>>,
    pub material: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MaterialMapping<'a>>>>>,
    pub texture: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextureMapping<'a>>>>>,
}
impl<'a> Default for GeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeometryArgs {
      type_: GeometryType::MultiPoint,
      lod: None,
      solids: None,
      shells: None,
      surfaces: None,
      strings: None,
      boundaries: None,
      semantics: None,
      semantics_objects: None,
      material: None,
      texture: None,
    }
  }
}

pub struct GeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GeometryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: GeometryType) {
    self.fbb_.push_slot::<GeometryType>(Geometry::VT_TYPE_, type_, GeometryType::MultiPoint);
  }
  #[inline]
  pub fn add_lod(&mut self, lod: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_LOD, lod);
  }
  #[inline]
  pub fn add_solids(&mut self, solids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SOLIDS, solids);
  }
  #[inline]
  pub fn add_shells(&mut self, shells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SHELLS, shells);
  }
  #[inline]
  pub fn add_surfaces(&mut self, surfaces: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SURFACES, surfaces);
  }
  #[inline]
  pub fn add_strings(&mut self, strings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_STRINGS, strings);
  }
  #[inline]
  pub fn add_boundaries(&mut self, boundaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_BOUNDARIES, boundaries);
  }
  #[inline]
  pub fn add_semantics(&mut self, semantics: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS, semantics);
  }
  #[inline]
  pub fn add_semantics_objects(&mut self, semantics_objects: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SemanticObject<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_SEMANTICS_OBJECTS, semantics_objects);
  }
  #[inline]
  pub fn add_material(&mut self, material: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MaterialMapping<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_MATERIAL, material);
  }
  #[inline]
  pub fn add_texture(&mut self, texture: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TextureMapping<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_TEXTURE, texture);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GeometryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Geometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Geometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Geometry");
      ds.field("type_", &self.type_());
      ds.field("lod", &self.lod());
      ds.field("solids", &self.solids());
      ds.field("shells", &self.shells());
      ds.field("surfaces", &self.surfaces());
      ds.field("strings", &self.strings());
      ds.field("boundaries", &self.boundaries());
      ds.field("semantics", &self.semantics());
      ds.field("semantics_objects", &self.semantics_objects());
      ds.field("material", &self.material());
      ds.field("texture", &self.texture());
      ds.finish()
  }
}
pub enum SemanticObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SemanticObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SemanticObject<'a> {
  type Inner = SemanticObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SemanticObject<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 6;
  pub const VT_CHILDREN: flatbuffers::VOffsetT = 8;
  pub const VT_PARENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SemanticObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SemanticObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<SemanticObject<'bldr>> {
    let mut builder = SemanticObjectBuilder::new(_fbb);
    if let Some(x) = args.parent { builder.add_parent(x); }
    if let Some(x) = args.children { builder.add_children(x); }
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> SemanticSurfaceType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SemanticSurfaceType>(SemanticObject::VT_TYPE_, Some(SemanticSurfaceType::RoofSurface)).unwrap()}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SemanticObject::VT_ATTRIBUTES, None)}
  }
  #[inline]
  pub fn children(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(SemanticObject::VT_CHILDREN, None)}
  }
  #[inline]
  pub fn parent(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SemanticObject::VT_PARENT, None)}
  }
}

impl flatbuffers::Verifiable for SemanticObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SemanticSurfaceType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("children", Self::VT_CHILDREN, false)?
     .visit_field::<u32>("parent", Self::VT_PARENT, false)?
     .finish();
    Ok(())
  }
}
pub struct SemanticObjectArgs<'a> {
    pub type_: SemanticSurfaceType,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub parent: Option<u32>,
}
impl<'a> Default for SemanticObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    SemanticObjectArgs {
      type_: SemanticSurfaceType::RoofSurface,
      attributes: None,
      children: None,
      parent: None,
    }
  }
}

pub struct SemanticObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SemanticObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: SemanticSurfaceType) {
    self.fbb_.push_slot::<SemanticSurfaceType>(SemanticObject::VT_TYPE_, type_, SemanticSurfaceType::RoofSurface);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SemanticObject::VT_CHILDREN, children);
  }
  #[inline]
  pub fn add_parent(&mut self, parent: u32) {
    self.fbb_.push_slot_always::<u32>(SemanticObject::VT_PARENT, parent);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SemanticObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SemanticObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SemanticObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SemanticObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SemanticObject");
      ds.field("type_", &self.type_());
      ds.field("attributes", &self.attributes());
      ds.field("children", &self.children());
      ds.field("parent", &self.parent());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CityFeature`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature(buf: &[u8]) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CityFeature>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature(buf: &[u8]) -> Result<CityFeature, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CityFeature>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CityFeature` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn root_as_city_feature_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CityFeature` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_city_feature_unchecked`.
pub fn size_prefixed_root_as_city_feature_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CityFeature<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CityFeature<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CityFeature`.
pub unsafe fn root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
  flatbuffers::root_unchecked::<CityFeature>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CityFeature and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CityFeature`.
pub unsafe fn size_prefixed_root_as_city_feature_unchecked(buf: &[u8]) -> CityFeature {
  flatbuffers::size_prefixed_root_unchecked::<CityFeature>(buf)
}
#[inline]
pub fn finish_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CityFeature<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_city_feature_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CityFeature<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
